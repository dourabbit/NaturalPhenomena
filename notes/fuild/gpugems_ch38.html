<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">
<html><head>





	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

	<title>GPU Gems - Chapter 38. Fast Fluid Dynamics Simulation on the GPU</title>

	<meta name="keywords" content="GPU GPGPU NVIDIA OpenGL Open_GL DirectX DX8 DX9 DX10 texture texture_mapping texturemap texture_map shading shader shaders realtime real_time CAD highperformancecomputing hpc gpu_compute tesla quadroplex geforce quadro hair skin cloth motion_blur dof depth_of_field anisotropic image_processing filtering filters volume volume_rendering financial">

	<link type="image/x-icon" href="http://www.nvidia.com/content/images/NVSphere.ico" rel="shortcut icon">

  <!-- <link rel="stylesheet" href="books.css" type="text/css" />	 -->



<style type="text/css">

body {

  min-width: 700px;      /* 2x LC width + RC width */

  

  font-family:Verdana, Geneva, Arial, Helvetica, Sans Serif;

  font-size: 11px;

  background-image:url('http://developer.nvidia.com/docs/TEMPLATE/423/developers_1px_bg_alt2.jpg');

  background-repeat: repeat-x;

  margin-left:5px;

  margin-top:0px;

}

#container {

  padding-top:55px;

  padding-left: 200px;   /* LC width */

  padding-right: 300px;  /* RC width */  

}

#container .column {

  position: relative;

  float: left;

}

#center {

  width: 100%;

  padding: 3px;

  background-color: #FFFFFF;

  border: medium solid #cccccc;

  border-width: 1px;

  

/*  borderColor: #dfdfe7;

  borderColorLight: #e9eaed; */

}

#left {

  width: 200px;          /* LC width */

  right: 200px;          /* LC width */  

  margin-left: -100%;

}



#container > #left {

  left: -200px;

  margin-left: expression(document.all.center.offsetWidth * -1);

}





#right {

  width: 300px;          /* RC width */

  margin-right: -300px;  /* RC width */  

}

#footer {

  clear: both;

}



#header {

height:80px;

background: transparent url(dev_site_header.jpg) no-repeat fixed top left;

clear: both;

}



/*** IE6 Fix ***/

* html #left {

  left: 315px;           /* RC width */

}



/* Original Holy Grail IE6 hack to stop the negative margin pulling the left column too far to the left, incorporating the 'left column disappearing hack' + the IE7 javascript fix */

#container > #leftcolumn {

  left: -100px;             /* Negative of (LC fullwidth + CC padding) = width for all browers other than IE7 */

  margin-left: expression(

  document.all.center.offsetWidth * -1 +

  parseFloat(document.all.center.currentStyle.paddingLeft) +

  parseFloat(document.all.left.currentStyle.paddingLeft) +

  parseFloat(document.all.left.currentStyle.paddingRight)

  ); /* Fix for IE7 */

}







#searchbar {

position: absolute;

top: 25px;

right:200px;

}

	

	

A { 

text-decoration:none;

/* color: #008000; */

/* green color: #76b900; */

/*font-weight:bold; */

color: #5B8C00;

}



A:hover { 

text-decoration:underline;

color: #000000;

}



A:visited { 

color: #5B8C00;

}	



input.searchbox {

font-family: Arial, Helvetica, sans-serif;

font-size: 11px;

color: #666666;

text-indent: 3px;

}



H1 { 

font-size:15px;

color: #000000;

font-weight:bold;

}

H2 { 

font-size:14px;

color: #000000;

font-weight:bold;

}

H3 { 

font-size:14px;

color: #000080;

font-weight:bold;

}

H4 { 

font-size:12px;

color: #000000;

font-weight:bold;

}

H5 { 

font-size:12px;

color: #000080;

font-weight:bold;

}

H6 { 

font-size:10px;

color: #000000;

font-weight:bold;

}

H6 { 

font-size:10px;

color: #000080;

font-weight:bold;

}



</style>

<style rel="stylesheet" id="D82CB4C7-16D8-4F07-8A5B-87A477EE7D82" type="text/css" charset="utf-8">SPAN.skype_pnh_container SPAN.skype_pnh_mark{  display:none !important;}@media screen{SPAN.skype_pnh_print_container_1319822120{  display:none !important;}SPAN.skype_pnh_container, SPAN.skype_pnh_container *{background-attachment: scroll !important;background-color: transparent !important;background-image: none !important;background-position: 0px 0px ! important;background-repeat: no-repeat !important;border: 0px none !important;border-color: #000000 !important;border-style: none !important;border-width: 0 !important;border-left: 0 none #000000 !important;border-top: 0 none #000000 !important;border-right: 0 none #000000 !important;border-bottom: 0 none #000000 !important;border-left-color: #000000 !important;border-left-style: none !important;border-left-width: 0 !important;border-top-color: #000000 !important;border-top-style: none !important;border-top-width: 0 !important;border-right-color: #000000 !important;border-right-style: none !important;border-right-width: 0 !important;border-bottom-color: #000000 !important;border-bottom-style: none !important;border-bottom-width: 0 !important;border-collapse: separate !important;bottom: auto !important;clear: none !important;clip: auto !important;cursor: pointer !important;direction: ltr !important;display: inline !important;float: none !important;font-style: normal !important;left: auto !important;letter-spacing: 0 !important;list-style-image: none !important;list-style-position: outside !important;list-style-type: disc !important;overflow: hidden !important;overflow-x: hidden !important;overflow-y: hidden !important;padding: 0px 0px 0px 0px !important;padding-left: 0px !important;padding-top: 0px !important;padding-right: 0px !important;padding-bottom: 0px !important;page-break-after: auto !important;page-break-before: auto !important;page-break-inside: auto !important;position: static !important;right: auto !important;table-layout: auto !important;text-align: left !important;text-decoration: none !important;text-indent: 0px !important;text-transform: none !important;top: auto !important;voice-family: inherit !important;white-space: nowrap !important;word-spacing: normal !important;z-index: 0 !important;  color: #49535A !important;  font-family: Tahoma, Arial, Helvetica, sans-serif !important;  font-size: 11px !important;  font-weight: bold !important;  height: 14px !important;  line-height: 14px !important;  margin-left: 0px !important;  margin-top: 0px !important;  margin-right: 0px !important;  margin-bottom: 0px !important;  vertical-align: baseline !important;  width: auto !important;}SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_active_fax SPAN.skype_pnh_right_span, SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_inactive_fax SPAN.skype_pnh_right_span{  background-position: -92px 0px !important;}SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_inactive_free SPAN.skype_pnh_dropart_flag_span{  background-position: 0px 1px !important;}SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_inactive_free SPAN.skype_pnh_textarea_span{  background-position: -90px 0px !important;}SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_inactive_free SPAN.skype_pnh_text_span{  visibility: hidden !important;}SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_active_free SPAN.skype_pnh_dropart_flag_span{  background-position: 0px 1px !important;}SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_active_free SPAN.skype_pnh_textarea_span{  background-position: -160px 0px !important;}SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_active_free SPAN.skype_pnh_text_span{  background-position: -160px 0px !important;  color: #FFFFFF !important;}SPAN.skype_pnh_container SPAN.skype_pnh_left_span{  background-position: 0px 0px !important;  width: 6px !important;}SPAN.skype_pnh_container SPAN.skype_pnh_dropart_span{  background-position: -11px 0px !important;  width: 27px !important;}SPAN.skype_pnh_container SPAN.skype_pnh_dropart_wo_arrow_span{  background-position: -130px 0px !important;  width: 18px !important;}SPAN.skype_pnh_container SPAN.skype_pnh_dropart_flag_span{  background-position: 1px 1px !important;  width: 18px !important;}SPAN.skype_pnh_container SPAN.skype_pnh_textarea_span{  background-position: -125px 0px !important;}SPAN.skype_pnh_container SPAN.skype_pnh_text_span{  padding-left: 5px !important;  background-position: -125px 0px !important;}SPAN.skype_pnh_container SPAN.skype_pnh_right_span{  background-position: -62px 0px !important;  width: 15px !important;}}@media print{SPAN.skype_pnh_print_container_1319822120{}SPAN.skype_pnh_container{    display:none !important;}}@media screen{SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_inactive_common *{  background-image:url('chrome://skype_ff_extension/skin/numbers_common_inactive_icon_set.gif') !important;}SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_active_common *{  background-image:url('chrome://skype_ff_extension/skin/numbers_common_active_icon_set.gif') !important;}SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_inactive_fax *{  background-image:url('chrome://skype_ff_extension/skin/numbers_common_inactive_icon_set.gif') !important;}SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_active_fax *{  background-image:url('chrome://skype_ff_extension/skin/numbers_common_active_icon_set.gif') !important;}SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_inactive_free SPAN.skype_pnh_text_span{  background-image: none !important;  color: transparent !important;  visibility: visible !important;}SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_inactive_free *{  background-image:url('chrome://skype_ff_extension/skin/numbers_free_icon_set.gif') !important;}SPAN.skype_pnh_container SPAN.skype_pnh_highlighting_active_free *{  background-image:url('chrome://skype_ff_extension/skin/numbers_free_icon_set.gif') !important;}SPAN.skype_pnh_container SPAN.skype_pnh_dropart_flag_span{  background-image: url('chrome://skype_ff_extension/skin/flags.gif') !important;}}</style></head><body>





<div id="header">

</div>



<div id="searchbar">



<form method="get" action="http://search.developer.nvidia.com/" name="search">



<input style="font-size: 11px; color: rgb(102, 102, 102); text-indent: 3px;" name="q" size="20" maxlength="50" onfocus="javascript:document.search.q.value = '';" value="Search" type="text">



</form>



</div>





<div id="container">

  <div id="center" class="column">

		<a href="http://developer.nvidia.com/object/gpu_gems_home.html"><img src="gpugems_ch38_files/GPU_Gems_1.jpg" align="left" border="0" hspace="5"> <h1>GPU Gems</h1></a>

		<b>GPU Gems</b> is now available, right here, online. You can <a href="http://www.informit.com/promotion/136275">purchase a beautifully printed version of this book</a>, and others in the series, at a 30% discount courtesy of InformIT and Addison-Wesley. 

<br><br>

Please visit our <a href="http://developer.nvidia.com/object/all_documents.html">Recent Documents</a> page to see all the latest whitepapers and conference presentations that can help you with your projects.	

		

		<br><br><br>

		<hr>

<h1>Chapter 38. Fast Fluid Dynamics Simulation on the GPU</h1>



<p>
   <em>Mark J. Harris <br>University of North Carolina at Chapel Hill</em>
</p>

<p>This chapter describes a method for fast, stable fluid simulation 
that runs entirely on the GPU. It introduces fluid dynamics and the 
associated mathematics, and it describes in detail the techniques to 
perform the simulation on the GPU. After reading this chapter, you 
should have a basic understanding of fluid dynamics and know how to 
simulate fluids using the GPU. The source code accompanying this book 
demonstrates the techniques described in this chapter.</p>





<h2>38.1 Introduction</h2>

<p>Fluids are everywhere: water passing between riverbanks, smoke curling from
  a glowing cigarette, steam rushing from a teapot, water vapor forming into
  clouds, and paint being mixed in a can. Underlying all of them is the flow
  of fluids. All are phenomena that we would like to portray realistically in
interactive graphics applications. Figure 38-1 shows examples of fluids simulated using the source code provided with this book.</p>

<div class="figure">
   <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/fig38-01.jpg">
      <img src="gpugems_ch38_files/fig38-01.jpg" alt="fig38-01.jpg">
   </a>
   <p>
      <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/fig38-01.jpg">Figure 38-1</a> Colored "Dye" Carried by a Swirling Fluid</p>
</div>

<p>Fluid simulation is a useful building block that is the basis for 
simulating a variety of natural phenomena. Because of the large amount 
of parallelism in graphics hardware, the simulation we describe runs 
significantly faster on the GPU than on the CPU. Using an NVIDIA GeForce
 FX, we have achieved a speedup of up to six times over an equivalent 
CPU simulation.</p>



<h4>38.1.1 Our Goal</h4>

<p>Our goal is to assist you in learning a powerful tool, not just to 
teach you a new trick. Fluid dynamics is such a useful component of more
 complex simulations that treating it as a black box would be a mistake.
 Without understanding the basic physics and mathematics of fluids, 
using and extending the algorithms we present would be very difficult. 
For this reason, we did not skimp on the mathematics here. As a result, 
this chapter contains many potentially daunting equations. Wherever 
possible, we provide clear explanations and draw connections between the
 math and its implementation.</p>



<h4>38.1.2 Our Assumptions</h4>

<p>The reader is expected to have at least a college-level calculus 
background, including a basic grasp of differential equations. An 
understanding of vector calculus principles is helpful, but not required
 (we will review what we need). Also, experience with finite difference 
approximations of derivatives is useful. If you have ever implemented 
any sort of physical simulation, such as projectile motion or rigid body
 dynamics, many of the concepts we use will be familiar.</p>




<h4>38.1.3 Our Approach</h4>

<p>The techniques we describe are based on the "stable fluids" method of
 Stam 1999. However, while Stam's simulations used a CPU implementation,
 we choose to implement ours on graphics hardware because GPUs are well 
suited to the type of computations required by fluid simulation. The 
simulation we describe is performed on a grid of cells. Programmable 
GPUs are optimized for performing computations on pixels, which we can 
consider to be a grid of cells. GPUs achieve high performance through 
parallelism: they are capable of processing multiple vertices and pixels
 simultaneously. They are also optimized to perform multiple texture 
lookups per cycle. Because our simulation grids are stored in textures, 
this speed and parallelism is just what we need.</p>

<p>This chapter cannot teach you everything about fluid dynamics. The 
scope of the simulation concepts that we can cover here is necessarily 
limited. We restrict ourselves to simulation of a continuous volume of 
fluid on a two-dimensional rectangular domain. Also, we do not simulate <em>free surface</em>
 boundaries between fluids, such as the interface between sloshing water
 and air. There are many extensions to these basic techniques. We 
mention a few of these at the end of the chapter, and we provide 
pointers to further reading about them.</p>

<p>We use consistent mathematical notation throughout the chapter. In equations, <em>italics</em> are used for variables that represent scalar quantities, such as pressure, <em>p</em>. <strong>Boldface</strong> is used to represent vector quantities, such as velocity, <strong>u</strong>. All vectors in this chapter are assumed to be two-dimensional.</p>

<p>Section 38.2 provides a mathematical background, including a 
discussion of the equations that govern fluid flow and a review of basic
 vector calculus concepts and notation. It then discusses the approach 
to solving the equations. Section 38.3 describes implementation of the 
fluid simulation on the GPU. Section 38.4 describes some applications of
 the simulation, Section 38.5 presents extensions, and Section 38.6 
concludes the chapter.</p>


<h2>38.2 Mathematical Background</h2>

<p>To simulate the behavior of a fluid, we must have a mathematical 
representation of the state of the fluid at any given time. The most 
important quantity to represent is the velocity of the fluid, because 
velocity determines how the fluid moves itself and the things that are 
in it. The fluid's velocity varies in both time and space, so we 
represent it as a <em>vector field</em>.</p>

<p>A vector field is a mapping of a vector-valued function onto a 
parameterized space, such as a Cartesian grid. (Other spatial 
parameterizations are possible, but for purposes of this chapter we 
assume a two-dimensional Cartesian grid.) The velocity vector field of 
our fluid is defined such that for every position <strong>x</strong> = (<em>x</em>, <em>y</em>), there is an associated velocity at time <em>t</em>, <strong>u</strong>(<strong>x</strong>, <em>t</em>) = (<em>u</em>(<strong>x</strong>, <em>t</em>), <em>v</em>(<strong>x</strong>, <em>t</em>), <em>w</em>(<strong>x</strong>, <em>t</em>)),
as shown in Figure 38-2.</p>

<div class="figure">
   <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/fig38-02.jpg">
      <img src="gpugems_ch38_files/fig38-02.jpg" alt="fig38-02.jpg">
   </a>
   <p>
      <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/fig38-02.jpg">Figure 38-2</a> The Fluid Velocity Grid</p>
</div>

<p>The key to fluid simulation is to take steps in time and, at each 
time step, correctly determine the current velocity field. We can do 
this by solving a set of equations that describes the evolution of the 
velocity field over time, under a variety of forces. Once we have the 
velocity field, we can do interesting things with it, such as using it 
to move objects, smoke densities, and other quantities that can be 
displayed in our application.</p>



<h4>38.2.1 The Navier-Stokes Equations for Incompressible Flow</h4>

<p>In physics it's common to make simplifying assumptions when modeling 
complex phenomena. Fluid simulation is no exception. We assume an <em>incompressible, homogeneous</em> fluid.</p>

<p>A fluid is incompressible if the volume of any subregion of the fluid
 is constant over time. A fluid is homogeneous if its density, <em><font face="symbol">r</font></em>,
 is constant in space. The combination of incompressibility and 
homogeneity means that density is constant in both time and space. These
 assumptions are common in fluid dynamics, and they do not decrease the 
applicability of the resulting mathematics to the simulation of real 
fluids, such as water and air.</p>

<p>We simulate fluid dynamics on a regular Cartesian grid with spatial coordinates <strong>x</strong> = (<em>x</em>, <em>y</em>) and time variable <em>t</em>. The fluid is represented by its velocity field <strong>u</strong>(<strong>x</strong>, <em>t</em>), as described earlier, and a scalar pressure field <em>p</em>(<strong>x</strong>, <em>t</em>). These fields vary in both space and time. If the velocity and pressure are known for the initial time <em>t</em> = 0, then the state of the fluid over time can be described by the <em>Navier-Stokes equations for incompressible flow</em>:</p>



<p>
   <strong>
      <a name="ch38equ01">Equation 1 </a></strong>
</p>


<p>

<a name="ch38equ01">   </a><a>
      <img src="gpugems_ch38_files/641equ01.jpg" alt="641equ01.jpg" border="0" hspace="5">
   </a>
</p>



<br>



<p>
   <strong>
      <a name="ch38equ02">Equation 2 </a></strong>
</p>


<p>

<a name="ch38equ02">   </a><a>
      <img src="gpugems_ch38_files/641equ02.jpg" alt="641equ02.jpg" border="0" hspace="5">
   </a>
</p>



<br>

<p>where <em><font face="symbol">r</font></em> is the (constant) fluid density, <em><font face="symbol">n</font></em> is the kinematic viscosity, and <strong>F</strong> = (<em>f<sub>x</sub>
   </em>, <em>f<sub>y</sub>
   </em>) represents any external forces that act on the fluid. Notice that Equation 1 is actually two equations, because <strong>u</strong> is a vector quantity:</p>

<p>
   <img src="gpugems_ch38_files/641equ03.jpg" alt="641equ03.jpg">
</p>

<p>
   <img src="gpugems_ch38_files/641equ04.jpg" alt="641equ04.jpg">
</p>

<p>Thus, we have three unknowns (<em>u</em>, <em>v</em>, and <em>p</em>) and three equations.</p>

<p>The Navier-Stokes equations may initially seem daunting, but like 
many complex concepts, we can better understand them by breaking them 
into simple pieces. Don't worry if the individual mathematical 
operations in the equations don't make sense yet. First, we will try to 
understand the different factors influencing the fluid flow. The four 
terms on the right-hand side of Equation 1 are accelerations. We'll look
 at them each in turn.</p>




<h4>38.2.2 Terms in the Navier-Stokes Equations</h4>


<h4> Advection</h4>

<p>The velocity of a fluid causes the fluid to transport objects, 
densities, and other quantities along with the flow. Imagine squirting 
dye into a moving fluid. The dye is transported, or <em>advected</em>, along the fluid's velocity field. In fact, the velocity of a fluid carries <em>itself</em> along just as it carries the dye. The first term on the right-hand side of Equation 1 represents this <em>self-advection</em> of the velocity field and is called the advection term.</p>



<h4> Pressure</h4>

<p>Because the molecules of a fluid can move around each other, they 
tend to "squish" and "slosh." When force is applied to a fluid, it does 
not instantly propagate through the entire volume. Instead, the 
molecules close to the force push on those farther away, and pressure 
builds up. Because pressure is force per unit area, any pressure in the 
fluid naturally leads to acceleration. (Think of Newton's second law, <strong>F</strong> = <em>m</em>
   <strong>a</strong>.) The second term, called the <em>pressure term</em>, represents this acceleration.</p>



<h4> Diffusion</h4>

<p>From experience with real fluids, you know that some fluids are 
"thicker" than others. For example, molasses and maple syrup flow 
slowly, but rubbing alcohol flows quickly. We say that thick fluids have
 a high <em>viscosity</em>. Viscosity is a measure of how resistive a 
fluid is to flow. This resistance results in diffusion of the momentum 
(and therefore velocity), so we call the third term the diffusion term.</p>



<h4> External Forces</h4>

<p>The fourth term encapsulates acceleration due to external forces applied to the fluid. These forces may be either <em>local forces</em> or <em>body forces</em>.
 Local forces are applied to a specific region of the fluid—for example,
 the force of a fan blowing air. Body forces, such as the force of 
gravity, apply evenly to the entire fluid.</p>

<p>We will return to the Navier-Stokes equations after a quick review of
 vector calculus. For a detailed derivation and more details, we 
recommend Chorin and Marsden 1993 and Griebel et al. 1998.</p>




<h4>38.2.3 A Brief Review of Vector Calculus</h4>

<p>Equations 1 and 2 contain three different uses of the symbol <img src="gpugems_ch38_files/U2207.GIF" class="articleIcon" alt="U2207.GIF"> (often pronounced "del"), which is also known as the <em>nabla</em>
 operator. The three applications of nabla are the gradient, the 
divergence, and the Laplacian operators, as shown in Table 38-1. The 
subscripts <em>i</em> and <em>j</em> used in the expressions in the table refer to discrete locations on a Cartesian grid, and <em><font face="symbol">d</font>x</em> and <em><font face="symbol">d</font>y</em> are the grid spacing in the <em>x</em> and <em>y</em> dimensions,
respectively (see Figure 38-2).</p>

<h4>Table 38-1. Vector Calculus Operators Used in Fluid Simulation</h4>
<img src="gpugems_ch38_files/tab38_1.jpg" width="500" height="181">

<p>The gradient of a scalar field is a vector of partial derivatives of 
the scalar field. Divergence, which appears in Equation 2, has an 
important physical significance. It is the rate at which "density" exits
 a given region of space. In the Navier-Stokes equations, it is applied 
to the velocity of the flow, and it measures the net change in velocity 
across a surface surrounding a small piece of the fluid. Equation 2, the
 <em>continuity equation</em>, enforces the incompressibility assumption
 by ensuring that the fluid always has zero divergence. The dot product 
in the divergence operator results in a sum of partial derivatives 
(rather than a vector, as with the gradient operator). This means that 
the divergence operator can be applied only to a vector field, such as 
the velocity, <strong>u</strong> = (<em>u</em>, <em>v</em>).</p>

<p>Notice that the gradient of a scalar field is a vector field, and the
 divergence of a vector field is a scalar field. If the divergence 
operator is applied to the result of the gradient operator, the result 
is the <em>Laplacian</em> operator <img src="gpugems_ch38_files/U2207.GIF" class="articleIcon" alt="U2207.GIF"> · <img src="gpugems_ch38_files/U2207.GIF" class="articleIcon" alt="U2207.GIF"> = <img src="gpugems_ch38_files/U2207.GIF" class="articleIcon" alt="U2207.GIF"><sup>2</sup>. If the grid cells are square (that is, if <em><font face="symbol">d</font>x</em> = <em><font face="symbol">d</font>y</em>, which we assume for the remainder of this chapter), the Laplacian simplifies to:</p>



<p>
   <strong>
      <a name="ch38equ03">Equation 3 </a></strong>
</p>


<p>

<a name="ch38equ03">   </a><a>
      <img src="gpugems_ch38_files/643equ07.jpg" alt="643equ07.jpg" border="0" hspace="5">
   </a>
</p>



<br>

<p>The Laplacian operator appears commonly in physics, most notably in 
the form of diffusion equations, such as the heat equation. Equations of
 the form <img src="gpugems_ch38_files/U2207.GIF" class="articleIcon" alt="U2207.GIF"><sup>2</sup>
   <em>x</em> = <em>b</em> are known as <em>Poisson equations</em>. The case where <em>b</em> = 0 is <em>Laplace's equation</em>,
 which is the origin of the Laplacian operator. In Equation 2, the 
Laplacian is applied to a vector field. This is a notational 
simplification: the operator is applied separately to each scalar 
component of the vector field.</p>



<h4>38.2.4 Solving the Navier-Stokes Equations</h4>

<p>The Navier-Stokes equations can be solved analytically for only a few
 simple physical configurations. However, it is possible to use 
numerical integration techniques to solve them incrementally. Because we
 are interested in watching the evolution of the flow over time, an 
incremental numerical solution suits our needs.</p>

<p>As with any algorithm, we must divide the solution of the 
Navier-Stokes equations into simple steps. The method we use is based on
 the <em>stable fluids</em> technique described in Stam 1999. In this 
section we describe the mathematics of each of these steps, and in 
Section 38.3 we describe their implementation using the Cg language on 
the GPU.</p>

<p>First we need to transform the equations into a form that is more 
amenable to numerical solution. Recall that the Navier-Stokes equations 
are three equations that we can solve for the quantities <em>u</em>, <em>v</em>, and <em>p</em>.
 However, it is not obvious how to solve them. The following section 
describes a transformation that leads to a straightforward algorithm.</p>


<h4> The Helmholtz-Hodge Decomposition</h4>

<p>Basic vector calculus tells us that any vector <strong>v</strong> can be decomposed into a set of basis vector components whose sum is <strong>v</strong>. For example, we commonly represent vectors on a Cartesian grid as a pair of distances along the grid axes: <strong>v</strong> = (<em>x</em>, <em>y</em>). The same vector can be written <strong>v</strong> = <em>x</em>
   <strong>î</strong> + <em>y</em>
   <strong><img src="gpugems_ch38_files/U0135.GIF" class="articleIcon" alt="U0135.GIF"></strong>, where <strong>î</strong> and <strong><img src="gpugems_ch38_files/U0135.GIF" class="articleIcon" alt="U0135.GIF"></strong> are unit basis vectors aligned to the axes of the grid.</p>

<p>In the same way that we can decompose a vector into a sum of vectors,
 we can also decompose a vector field into a sum of vector fields. Let <em>D</em>
 be the region in space, or in our case the plane, on which our fluid is
 defined. Let this region have a smooth (that is, differentiable) 
boundary, <em><img src="gpugems_ch38_files/U2202.GIF" class="articleIcon" alt="U2202.GIF">D</em>, with normal direction <strong>n</strong>. We can use the following theorem, as stated in Chorin and Marsden 1993.</p>

<blockquote>

   <p>
      <strong>Helmholtz-Hodge Decomposition Theorem</strong>
   </p>

   <p>A vector field <strong>w</strong> on <em>D</em> can be uniquely decomposed in the form:</p>



   <p>
      <strong>
         <a name="ch38equ04">Equation 7 </a></strong>
<a name="ch38equ04">   </a></p>


<a name="ch38equ04">   </a><p>

<a name="ch38equ04">      </a><a>
         <img src="gpugems_ch38_files/644equ01.jpg" alt="644equ01.jpg" border="0" hspace="5">
      </a>
   </p>



   <br>

   <p>where <strong>u</strong> has zero divergence and is parallel to <em><img src="gpugems_ch38_files/U2202.GIF" class="articleIcon" alt="U2202.GIF">D</em>; that is, <strong>u</strong> . <strong>n</strong> = 0 on <em><img src="gpugems_ch38_files/U2202.GIF" class="articleIcon" alt="U2202.GIF">D</em>.</p>

</blockquote>

<p>We use the theorem without proof. For details and a proof of this theorem, refer to Section 1.3 of Chorin and Marsden 1993.</p>

<p>This theorem states that any vector field can be decomposed into the 
sum of two other vector fields: a divergence-free vector field, and the 
gradient of a scalar field. It also says that the divergence-free field 
goes to zero at the boundary. It is a powerful tool, leading us to two 
useful realizations.</p>


<h4> First Realization</h4>

<p>Solving the Navier-Stokes equations involves three computations to 
update the velocity at each time step: advection, diffusion, and force 
application. The result is a new velocity field, <strong>w</strong>, with <em>nonzero</em>
 divergence. But the continuity equation requires that we end each time 
step with a divergence-free velocity. Fortunately, the Helmholtz-Hodge 
Decomposition Theorem tells us that the divergence of the velocity can 
be corrected by subtracting the gradient of the resulting pressure 
field:</p>



<p>
   <strong>
      <a name="ch38equ05">Equation 8 </a></strong>
</p>


<p>

<a name="ch38equ05">   </a><a>
      <img src="gpugems_ch38_files/645equ01.jpg" alt="645equ01.jpg" border="0" hspace="5">
   </a>
</p>



<br>



<h4> Second Realization</h4>

<p>The theorem also leads to a method for computing the pressure field. 
If we apply the divergence operator to both sides of Equation 7, we 
obtain:</p>



<p>
   <strong>
      <a name="ch38equ06">Equation 9 </a></strong>
</p>


<p>

<a name="ch38equ06">   </a><a>
      <img src="gpugems_ch38_files/645equ02.jpg" alt="645equ02.jpg" border="0" hspace="5">
   </a>
</p>



<br>

<p>But since Equation 2 enforces that <img src="gpugems_ch38_files/U2207.GIF" class="articleIcon" alt="U2207.GIF"> · <strong>u</strong> = 0, this simplifies to:</p>



<p>
   <strong>
      <a name="ch38equ07">Equation 10 </a></strong>
</p>


<p>

<a name="ch38equ07">   </a><a>
      <img src="gpugems_ch38_files/645equ03.jpg" alt="645equ03.jpg" border="0" hspace="5">
   </a>
</p>



<br>

<p>which is a Poisson equation (see Section 38.2.3) for the pressure of the fluid, sometimes called the <em>Poisson-pressure equation</em>. This means that after we arrive at our divergent velocity, <strong>w</strong>, we can solve Equation 10 for <em>p</em>, and then use <strong>w</strong> and <em>p</em> to compute the new divergence-free field, <strong>u</strong>, using Equation 8. We'll return to this later.</p>

<p>Now we need a way to compute <strong>w</strong>. To do this, let's 
return to our comparison of vectors and vector fields. From the 
definition of the dot product, we know that we can find the projection 
of a vector <strong>r</strong> onto a unit vector <strong><img src="gpugems_ch38_files/U015D.htm" class="articleIcon" alt="U015D.GIF"></strong> by computing the dot product of <strong>r</strong> and <strong><img src="gpugems_ch38_files/U015D.htm" class="articleIcon" alt="U015D.GIF"></strong>. The dot product is a projection operator for vectors that maps a vector <strong>r</strong> onto its component in the direction of <strong><img src="gpugems_ch38_files/U015D.htm" class="articleIcon" alt="U015D.GIF"></strong>. We can use the Helmholtz-Hodge Decomposition Theorem to define a projection operator, <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/p.jpg%27%29">
      <img src="gpugems_ch38_files/p.jpg" alt="p.jpg" border="0" hspace="5">
   </a>, that projects a vector field <strong>w</strong> onto its divergence-free component, <strong>u</strong>. If we apply <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/p.jpg">
      <img src="gpugems_ch38_files/p.jpg" alt="p.jpg" border="0" hspace="5">
   </a> to Equation 7, we get:</p>

<p>
   <img src="gpugems_ch38_files/646equ01.jpg" alt="646equ01.jpg">
</p>

<p>But by the definition of <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/p.jpg">
      <img src="gpugems_ch38_files/p.jpg" alt="p.jpg" border="0" hspace="5">
   </a>, <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/p.jpg">
      <img src="gpugems_ch38_files/p.jpg" alt="p.jpg" border="0" hspace="5">
   </a>
   <strong>w</strong> = <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/p.jpg">
      <img src="gpugems_ch38_files/p.jpg" alt="p.jpg" border="0" hspace="5">
   </a>
   <strong>u</strong> = <strong>u</strong>. Therefore, <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/p.jpg">
      <img src="gpugems_ch38_files/p.jpg" alt="p.jpg" border="0" hspace="5">
   </a>(<img src="gpugems_ch38_files/U2207.GIF" class="articleIcon" alt="U2207.GIF"><em>p</em>) = 0. Now let's use these ideas to simplify the Navier-Stokes equations.</p>

<p>First, we apply our projection operator to both sides of Equation 1:</p>

<p>
   <img src="gpugems_ch38_files/646equ02.jpg" alt="646equ02.jpg">
</p>

<p>Because <strong>u</strong> is divergence-free, so is the derivative on the left-hand side, so <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/p.jpg">
      <img src="gpugems_ch38_files/p.jpg" alt="p.jpg" border="0" hspace="5">
   </a>(<em><img src="gpugems_ch38_files/U2202.GIF" class="articleIcon" alt="U2202.GIF"></em>
   <strong>u</strong>/<em><img src="gpugems_ch38_files/U2202.GIF" class="articleIcon" alt="U2202.GIF">t</em>) = <em><img src="gpugems_ch38_files/U2202.GIF" class="articleIcon" alt="U2202.GIF"></em>
   <strong>u</strong>/<em><img src="gpugems_ch38_files/U2202.GIF" class="articleIcon" alt="U2202.GIF">t</em>. Also, <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/p.jpg%27%29">
      <img src="gpugems_ch38_files/p.jpg" alt="p.jpg" border="0" hspace="5">
   </a>(<img src="gpugems_ch38_files/U2207.GIF" class="articleIcon" alt="U2207.GIF"><em>p</em>) = 0, so the pressure term drops out. We're left with the following equation:</p>



<p>
   <strong>
      <a name="ch38equ08">Equation 11 </a></strong>
</p>


<p>

<a name="ch38equ08">   </a><a>
      <img src="gpugems_ch38_files/646equ03.jpg" alt="646equ03.jpg" border="0" hspace="5">
   </a>
</p>




<br>

<p>The great thing about this equation is that it symbolically 
encapsulates our entire algorithm for simulating fluid flow. We first 
compute what's inside the parentheses on the right-hand side. From left 
to right, we compute the advection, diffusion, and force terms. 
Application of these three steps results in a divergent velocity field, <strong>w</strong>, to which we apply our projection operator to get a new divergence-free field, <strong>u</strong>. To do so, we solve Equation 10 for <em>p</em>, and then subtract the gradient of <em>p</em> from <strong>w</strong>, as in Equation 8.</p>

<p>In a typical implementation, the various components are not computed 
and added together, as in Equation 11. Instead, the solution is found 
via composition of transformations on the state; in other words, each 
component is a step that takes a field as input, and produces a new 
field as output. We can define an operator <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/s.jpg">
      <img src="gpugems_ch38_files/s.jpg" alt="s.jpg" border="0" hspace="5">
   </a> that is equivalent to the solution of Equation 11 over a single 
time step. The operator is defined as the composition of operators for 
advection (<a href="http://http.developer.nvidia.com/GPUGems/elementLinks/a.jpg">
      <img src="gpugems_ch38_files/a.jpg" alt="a.jpg" border="0" hspace="5">
   </a>), diffusion (<a href="http://http.developer.nvidia.com/GPUGems/elementLinks/d.jpg">
      <img src="gpugems_ch38_files/d.jpg" alt="d.jpg" border="0" hspace="5">
   </a>), force application (<a href="http://http.developer.nvidia.com/GPUGems/elementLinks/f.jpg">
      <img src="gpugems_ch38_files/f.jpg" alt="f.jpg" border="0" hspace="5">
   </a>), and projection (<a href="http://http.developer.nvidia.com/GPUGems/elementLinks/p.jpg">
      <img src="gpugems_ch38_files/p.jpg" alt="p.jpg" border="0" hspace="5">
   </a>):</p>



<p>
   <strong>
      <a name="ch38equ09">Equation 12 </a></strong>
</p>


<p>

<a name="ch38equ09">   </a><a>
      <img src="gpugems_ch38_files/646equ04.jpg" alt="646equ04.jpg" border="0" hspace="5">
   </a>
</p>




<br>

<p>Thus, a step of the simulation algorithm can be expressed <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/su.jpg">
      <img src="gpugems_ch38_files/su.jpg" alt="su.jpg" border="0" hspace="5">
   </a> The operators are applied right to left; first advection, 
followed by diffusion, force application, and projection. Note that time
 is omitted here for clarity, but in practice, the time step must be 
used in the computation of each operator. Now let's look more closely at
 the advection and diffusion steps, and then approach the solution of 
Poisson equations.</p>





<h4> Advection</h4>

<p>Advection is the process by which a fluid's velocity transports 
itself and other quantities in the fluid. To compute the advection of a 
quantity, we must update the quantity at each grid point. Because we are
 computing how a quantity moves along the velocity field, it helps to 
imagine that each grid cell is represented by a particle. A first 
attempt at computing the result of advection might be to update the grid
 as we would update a particle system. Just move the position, <strong>r</strong>, of each particle forward along the velocity field the distance it would travel in time <em><font face="symbol">d</font>t</em>:</p>

<p>
   <img src="gpugems_ch38_files/647equ01.jpg" alt="647equ01.jpg">
</p>

<p>You might recognize this as Euler's method; it is a simple method for
 explicit (or forward) integration of ordinary differential equations. 
(There are more accurate methods, such as the midpoint method and the 
Runge-Kutta methods.)</p>

<p>There are two problems with this approach: The first is that 
simulations that use explicit methods for advection are unstable for 
large time steps, and they can "blow up" if the magnitude of <strong>u</strong>(<em>t</em>)<em><font face="symbol">d</font>t</em>
 is greater than the size of a single grid cell. The second problem is 
specific to GPU implementation. We implement our simulation in fragment 
programs, which cannot change the locations of the fragments they are 
writing. This forward-integration method requires the ability to "move" 
the particles, so it cannot be implemented on current GPUs.</p>

<p>The solution is to invert the problem and use an implicit method 
(Stam 1999). Rather than advecting quantities by computing where a 
particle moves over the current time step, we trace the trajectory of 
the particle from each grid cell back in time to its former position, 
and we copy the quantities at that position to the starting grid cell. 
To update a quantity <em>q</em> (this could be velocity, density, temperature, or any quantity carried by the fluid), we use the following equation:</p>



<p>
   <strong>
      <a name="ch38equ10">Equation 13 </a></strong>
</p>


<p>

<a name="ch38equ10">   </a><a>
      <img src="gpugems_ch38_files/647equ02.jpg" alt="647equ02.jpg" border="0" hspace="5">
   </a>
</p>



<br>

<p>Not only can we easily implement this method on the GPU, but as Stam 
showed,
it is stable for arbitrary time steps and velocities. Figure 38-3 
depicts the advection computation at the cell marked with a double 
circle. Tracing the velocity field back in time leads to the green <strong>x</strong>. The four grid values nearest the green <strong>x</strong> (connected by a green square in the figure) are bilinearly interpolated, and the result is written to the starting grid cell.</p>


<div class="figure">
   <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/fig38-03.jpg">
      <img src="gpugems_ch38_files/fig38-03.jpg" alt="fig38-03.jpg">
   </a>
   <p>
      <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/fig38-03.jpg">Figure 38-3</a> Computing Fluid Advection</p>
</div>



<h4> Viscous Diffusion</h4>

<p>As explained earlier, viscous fluids have a certain resistance to 
flow, which results in diffusion (or dissipation) of velocity. A partial
 differential equation for viscous diffusion is:</p>



<p>
   <strong>
      <a name="ch38equ11">Equation 14 </a></strong>
</p>


<p>

<a name="ch38equ11">   </a><a>
      <img src="gpugems_ch38_files/648equ01.jpg" alt="648equ01.jpg" border="0" hspace="5">
   </a>
</p>



<br>

<p>As in advection, we have a choice of how to solve this equation. An 
obvious approach is to formulate an explicit, discrete form in order to 
develop a simple algorithm:</p>

<p>
   <img src="gpugems_ch38_files/648equ02.jpg" alt="648equ02.jpg">
</p>

<p>In this equation, <img src="gpugems_ch38_files/U2207.GIF" class="articleIcon" alt="U2207.GIF"><sup>2</sup>
 is the discrete form of the Laplacian operator, Equation 3. Like the 
explicit Euler method for computing advection, this method is unstable 
for large values of <em><font face="symbol">d</font>t</em> and <em>v</em>. We follow Stam's lead again and use an implicit formulation of Equation 14:</p>



<p>
   <strong>
      <a name="ch38equ12">Equation 15 </a></strong>
</p>


<p>

<a name="ch38equ12">   </a><a>
      <img src="gpugems_ch38_files/648equ03.jpg" alt="648equ03.jpg" border="0" hspace="5">
   </a>
</p>



<br>

<p>where <strong>I</strong> is the identity matrix. This formulation is 
stable for arbitrary time steps and viscosities. This equation is a 
(somewhat disguised) Poisson equation for velocity. Remember that our 
use of the Helmholtz-Hodge decomposition results in a Poisson equation 
for pressure. These equations can be solved using an iterative 
relaxation technique.</p>



<h4> Solution of Poisson Equations</h4>

<p>We need to solve two Poisson equations: the Poisson-pressure equation
 and the viscous diffusion equation. Poisson equations are common in 
physics and well understood. We use an iterative solution technique that
 starts with an approximate solution and improves it every iteration.</p>

<p>The Poisson equation is a matrix equation of the form <strong>Ax</strong> = <strong>b</strong>, where <strong>x</strong> is the vector of values for which we are solving (<em>p</em> or <strong>u</strong> in our case), <strong>b</strong> is a vector of constants, and <strong>A</strong> is a matrix. In our case, <strong>A</strong> is implicitly represented in the Laplacian operator <img src="gpugems_ch38_files/U2207.GIF" class="articleIcon" alt="U2207.GIF"><sup>2</sup>,
 so it need not be explicitly stored as a matrix. The iterative solution
 technique we use starts with an initial "guess" for the solution, <strong>x</strong>
   <sup>(0)</sup>, and each step <em>k</em> produces an improved solution, <strong>x</strong>
   <sup>(<em>k</em>)</sup>. The superscript notation indicates the 
iteration number. The simplest iterative technique is called Jacobi 
iteration. A derivation of Jacobi iteration for general matrix equations
 can be found in Golub and Van Loan 1996.</p>

<p>More sophisticated methods, such as conjugate gradient and multigrid 
methods, converge faster, but we use Jacobi iteration because of its 
simplicity and easy implementation. For details and examples of more 
sophisticated solvers, see Bolz et al. 2003, Goodnight et al. 2003, and 
Krüger and Westermann 2003.</p>

<p>Equations 10 and 15 appear different, but both can be discretized using Equation 3 and rewritten in the form:</p>



<p>
   <strong>
      <a name="ch38equ13">Equation 16 </a></strong>
</p>


<p>

<a name="ch38equ13">   </a><a>
      <img src="gpugems_ch38_files/649equ01.jpg" alt="649equ01.jpg" border="0" hspace="5">
   </a>
</p>



<br>

<p>where <em><font face="symbol">a</font></em> and <em><font face="symbol">b</font></em> are constants. The values of <em>x</em>, <em>b</em>, <em><font face="symbol">a</font></em>, and <em><font face="symbol">b</font></em> are different for the two equations. In the Poisson-pressure equation, <em>x</em> represents <em>p</em>, <em>b</em> represents <img src="gpugems_ch38_files/U2207.GIF" class="articleIcon" alt="U2207.GIF"> · <strong>w</strong>, <em><font face="symbol">a</font></em> = -(<em><font face="symbol">d</font>x</em>)<sup>2</sup>, and <em><font face="symbol">b</font></em> = 4.<sup>
      <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/ch38fn01.html">
      [1]
    </a>
   </sup> For the viscous diffusion equation, both <em>x</em> and <em>b</em> represent <strong>u</strong>, <em><font face="symbol">a</font></em> = (<em><font face="symbol">d</font>x</em>)<sup>2</sup>/<em><font face="symbol">n</font><font face="symbol">d</font>t</em>, and <em><font face="symbol">b</font></em> = 4 + <em><font face="symbol">a</font></em>.</p>

<p>We formulate the equations this way because it lets us use the same 
code to solve either equation. To solve the equations, we simply run a 
number of iterations in which we apply Equation 16 at every grid cell, 
using the results of the previous iteration as input to the next (<strong>x</strong>
   <sup>(</sup>
   <sup>
      <em>k</em>
   </sup>
   <sup>+1)</sup> becomes <strong>x</strong>
   <sup>(</sup>
   <sup>
      <em>k</em>
   </sup>
   <sup>)</sup>). Because Jacobi iteration converges slowly, we need to 
execute many iterations. Fortunately, Jacobi iterations are cheap to 
execute on the GPU, so we can run many iterations in a very short time.</p>



<h4> Initial and Boundary Conditions</h4>

<p>Any differential equation problem defined on a finite domain requires <em>boundary conditions</em>
 in order to be well posed. The boundary conditions determine how we 
compute values at the edges of the simulation domain. Also, to compute 
the evolution of the flow over time, we must know how it started—in 
other words, its <em>initial conditions</em>. For our fluid simulation, 
we assume the fluid initially has zero velocity and zero pressure 
everywhere. Boundary conditions require a bit more discussion.</p>

<p>During each time step, we solve equations for two quantities—velocity
 and pressure—and we need boundary conditions for both. Because our 
fluid is simulated on a rectangular grid, we assume that it is a fluid 
in a box and cannot flow through the sides of the box. For velocity, we 
use the <em>no-slip</em> condition, which specifies that velocity goes 
to zero at the boundaries. The correct solution of the Poisson-pressure 
equation requires <em>pure Neumann</em> boundary conditions: <em><img src="gpugems_ch38_files/U2202.GIF" class="articleIcon" alt="U2202.GIF">p</em>/<em><img src="gpugems_ch38_files/U2202.GIF" class="articleIcon" alt="U2202.GIF"></em>
   <strong>n</strong> = 0. This means that at a boundary, the rate of 
change of pressure in the direction normal to the boundary is zero. We 
revisit boundary conditions at the end of Section 38.3.</p>



<h2>38.3 Implementation</h2>

<p>Now that we understand the problem and the basics of solving it, we 
can move forward with the implementation. A good place to start is to 
lay out some pseudocode for the algorithm. The algorithm is the same 
every time step, so this pseudocode represents a single time step. The 
variables <tt>u</tt> and <tt>p</tt> hold the velocity and pressure field data.</p>

<pre><strong><em>// Apply the first 3 operators in Equation 12.</em></strong>
u = advect(u);
u = diffuse(u);
u = addForces(u);
<strong><em>// Now apply the projection operator to the result.</em></strong>
p = computePressure(u);
u = subtractPressureGradient(u, p);</pre>

<p>In practice, temporary storage is needed, because most of these 
operations cannot be performed in place. For example, the advection step
 in the pseudocode is more accurately written as:</p>

<pre>uTemp = advect(u);
swap(u, uTemp);</pre>

<p>This pseudocode contains no implementation-specific details. In fact,
 the same pseudocode describes CPU and GPU implementations equally well.
 Our goal is to perform all the steps on the GPU. Computation of this 
sort on the GPU may be unfamiliar to some readers, so we will draw some 
analogies between operations in a typical CPU fluid simulation and their
 counterparts on the GPU.</p>


<h4>38.3.1 CPU–GPU Analogies</h4>

<p>Fundamental to any computer are its memory and processing models, so 
any application must consider data representation and computation. Let's
 touch on the differences between CPUs and GPUs with regard to both of 
these.</p>


<h4> Textures = Arrays</h4>

<p>Our simulation represents data on a two-dimensional grid. The natural
 representation for this grid on the CPU is an array. The analog of an 
array on the GPU is a texture. Although textures are not as flexible as 
arrays, their flexibility is improving as graphics hardware evolves. 
Textures on current GPUs support all the basic operations necessary to 
implement a fluid simulation. Because textures usually have three or 
four color channels, they provide a natural data structure for vector 
data types with two to four components. Alternatively, multiple scalar 
fields can be stored in a single texture. The most basic operation is an
 array (or memory) read, which is accomplished by using a texture 
lookup. Thus, the GPU analog of an array offset is a texture coordinate.
 We need at least two textures to represent the state of the fluid: one 
for velocity and one for pressure. In order to visualize the flow, we 
maintain an additional texture that contains a quantity carried by the 
fluid. We can think of this as "ink." Figure
38-4 shows examples of these textures, as well as an additional texture 
for vorticity, described in Section 38.5.1.</p>

<div class="figure">
   <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/fig38-04.jpg">
      <img src="gpugems_ch38_files/fig38-04.jpg" alt="fig38-04.jpg">
   </a>
   <p>
      <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/fig38-04.jpg">Figure 38-4</a> The State Fields of a Fluid Simulation, Stored in Textures</p>
</div>



<h4> Loop Bodies = Fragment Programs</h4>

<p>A CPU implementation of the simulation performs the steps in the 
algorithm by looping, using a pair of nested loops to iterate over each 
cell in the grid. At each cell, the same computation is performed. GPUs 
do not have the capability to perform this inner loop over each texel in
 a texture. However, the fragment pipeline is designed to perform 
identical computations at each fragment. To the programmer, it appears 
as if there is a processor for each fragment, and that all fragments are
 updated simultaneously. In the parlance of parallel programming, this 
model is known as single instruction, multiple data (SIMD) computation. 
Thus, the GPU analog of computation inside nested loops over an array is
 a fragment program applied in SIMD fashion to each fragment.</p>



<h4> Feedback = Texture Update</h4>

<p>In Section 38.2.4, we described how we use Jacobi iteration to solve 
Poisson equations. This type of iterative method uses the result of an 
iteration as input for the next iteration. This <em>feedback</em> is 
common in numerical methods. In a CPU implementation, one typically does
 not even consider feedback, because it is trivially implemented using 
variables and arrays that can be both read and written. On the GPU, 
though, the output of fragment processors is always written to the frame
 buffer. Think of the frame buffer as a two-dimensional array that 
cannot be directly read. There are two ways to get the contents of the 
frame buffer into a texture that can be read:</p>

<ul>
   <li>
      <em>Copy to texture</em> (CTT) copies from the frame buffer to a texture.</li>
   <li>
      <em>Render to texture</em> (RTT) uses a texture as the frame buffer so the GPU can write directly to it.</li>
</ul>

<p>CTT and RTT function equally well, but have a performance trade-off. 
For the sake of generality we do not assume the use of either and refer 
to the process of writing to a texture as a <em>texture update</em>.</p>

<p>Earlier we mentioned that, in practice, each of the five steps in the
 algorithm updates a temporary grid and then performs a swap. RTT 
requires the use of two textures to implement feedback, because the 
results of rendering to a texture while it is bound for reading are 
undefined. The swap in this case is merely a swap of texture IDs. The 
performance cost of RTT is therefore constant. CTT, on the other hand, 
requires only one texture. The frame buffer acts as a temporary grid, 
and a swap is performed by copying the data from the frame buffer to the
 texture. The performance cost of this copy is proportional to the 
texture size.</p>




<h4>38.3.2 Slab Operations</h4>

<p>We break down the steps of our simulation into what we call <em>slab operations</em> (<em>slabop</em>, for short).<sup>
      <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/ch38fn02.html">
      [2]
    </a>
   </sup> Each slabop consists of processing one or more (often all) 
fragments in the frame buffer—usually with a fragment program 
active—followed by a texture update. Fragment processing is driven by 
rendering geometric primitives. For this application, the geometry we 
render is simple: just quad and line primitives.</p>

<p>There are two types of fragments to process in any slab operation: interior
  fragments and boundary fragments. Our 2D grid reserves a single-cell perimeter
  to store and compute boundary conditions. Typically, a different computation
  is performed on the interior and at the boundaries. To update the interior
  fragments, we render a quadrilateral that covers all but a one-pixel border
  on the perimeter of the frame buffer. We render four line primitives to update
  the boundary cells. We apply separate fragment programs to interior and border
fragments. See Figure 38-5.</p>

<div class="figure">
   <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/fig38-05.jpg">
      <img src="gpugems_ch38_files/fig38-05.jpg" alt="fig38-05.jpg">
   </a>
   <p>
      <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/fig38-05.jpg">Figure 38-5</a> Primitives Used to Update the Interior and Boundaries of the Grid</p>
</div>



<h4>38.3.3 Implementation in Fragment Programs</h4>

<p>Now that we know the steps of our algorithm, our data representation,
 and how to perform a slab operation, we can write the fragment programs
 that perform computations at each cell.</p>


<h4> Advection</h4>

<p>The fragment program implementation of advection shown in Listing 38-1 follows nearly exactly from Equation 13, repeated here:</p>



<p>
   <strong>
      <a name="ch38equ14">Equation 13 </a></strong>
</p>


<p>

<a name="ch38equ14">   </a><a>
      <img src="gpugems_ch38_files/653equ01.jpg" alt="653equ01.jpg" border="0" hspace="5">
   </a>
</p>



<br>

<p>There is one slight difference. Because texture coordinates are not 
in the same units as our simulation domain (the texture coordinates are 
in the range [0, <em>N</em>], where <em>N</em> is the grid resolution), 
we must scale the velocity into grid space. This is reflected in Cg code
 with the multiplication of the local velocity by the parameter <tt>rdx</tt>, which represents the reciprocal of the grid scale <em><font face="symbol">d</font>x</em>. The texture wrap mode must be set to <tt>CLAMP_TO_EDGE</tt> so that back-tracing outside the range [0, <em>N</em>]
 will be clamped to the boundary texels. The boundary conditions 
described later correctly update these texels so that this situation 
operates correctly.</p>



<h4>Example 38-1. Advection Fragment Program</h4>


<pre><strong><em>void</em></strong> advect(<strong><em>float2</em></strong> coords   : <strong><em>WPOS</em></strong>,   <strong><em>// grid coordinates</em></strong>
            
   <strong><em>out float4</em></strong> xNew : <strong><em>COLOR</em></strong>,  <strong><em>// advected qty</em></strong>
            
   <strong><em>uniform float</em></strong> timestep,
            <strong><em>uniform</em></strong> 
   <strong><em>float</em></strong> rdx,        <strong><em>// 1 / grid scale</em></strong>
            
   <strong><em>uniform</em></strong> 
   <strong><em>samplerRECT</em></strong> u,    <strong><em>// input velocity</em></strong>
            
   <strong><em>uniform</em></strong> 
   <strong><em>samplerRECT</em></strong> x)    <strong><em>// qty to advect</em></strong>
{
  <strong><em>// follow the velocity field "back in time"</em></strong>
  
   <strong><em>float2</em></strong> pos = coords - timestep * rdx * <strong><em>f2texRECT</em></strong>(u, coords);

  <strong><em>// interpolate and write to the output fragment</em></strong>
  xNew = f4texRECTbilerp(x, pos);
}</pre>


<p>In this code, the parameter <tt>u</tt> is the velocity field texture, and <tt>x</tt> is the field that is to be advected. This could be the velocity or another quantity, such as dye concentration. The function <tt>f4texRECTbilerp()</tt>
 is a utility to perform bilinear interpolation of the four texels 
closest to the texture coordinates passed to it. Because current GPUs do
 not support automatic bilinear interpolation in floating-point 
textures, we must implement it with this type of code.</p>



<h4> Viscous Diffusion</h4>

<p>With the description of the Jacobi iteration technique given in 
Section 38.2.4, writing a Jacobi iteration fragment program is simple, 
as shown in Listing 38-2.</p>



<h4>Example 38-2. The Jacobi Iteration Fragment Program Used to Solve Poisson Equations</h4>


<pre><strong><em>void</em></strong> jacobi(<strong><em>half2</em></strong> coords   : <strong><em>WPOS</em></strong>,   <strong><em>// grid coordinates</em></strong>
            
   <strong><em>out</em></strong> 
   <strong><em>half4</em></strong> xNew : <strong><em>COLOR</em></strong>,  <strong><em>// result</em></strong>
            
   <strong><em>uniform</em></strong> 
   <strong><em>half</em></strong> alpha,
            <strong><em>uniform</em></strong> 
   <strong><em>half</em></strong> rBeta,      <strong><em>// reciprocal beta</em></strong>
            
   <strong><em>uniform samplerRECT</em></strong> x,   <strong><em>// x vector (Ax = b)</em></strong>
            
   <strong><em>uniform samplerRECT</em></strong> b)   <strong><em>// b vector (Ax = b)</em></strong>
{
  <strong><em>// left, right, bottom, and top x samples</em></strong>
  
  <strong><em>half4</em></strong> xL = <strong><em>h4texRECT</em></strong>(x, coords - <strong><em>half2</em></strong>(1, 0));
  <strong><em>half4</em></strong> xR = <strong><em>h4texRECT</em></strong>(x, coords + <strong><em>half2</em></strong>(1, 0));
  <strong><em>half4</em></strong> xB = <strong><em>h4texRECT</em></strong>(x, coords - <strong><em>half2</em></strong>(0, 1));
  <strong><em>half4</em></strong> xT = <strong><em>h4texRECT</em></strong>(x, coords + <strong><em>half2</em></strong>(0, 1));

  <strong><em>// b sample, from center</em></strong>
  
   <strong><em>half4</em></strong> bC = <strong><em>h4texRECT</em></strong>(b, coords);

  <strong><em>// evaluate Jacobi iteration</em></strong>
  xNew = (xL + xR + xB + xT + alpha * bC) * rBeta;
}</pre>


<p>Notice that the <tt>rBeta</tt> parameter is the reciprocal of <em><font face="symbol">b</font></em> from Equation 16. To solve the diffusion equation, we set <tt>alpha</tt> to (<em><font face="symbol">d</font>x</em>)<sup>2</sup>/<em><font face="symbol">n</font><font face="symbol">d</font>t</em>, <tt>rBeta</tt> to 1/(4 + (<em><font face="symbol">d</font>x</em>)<sup>2</sup>/<em><font face="symbol">n</font><font face="symbol">d</font>t</em>), and the <tt>x</tt> and <tt>b</tt>
 parameters to the velocity texture. We then run a number of iterations 
(usually 20 to 50, but more can be used to reduce the error).</p>



<h4> Force Application</h4>

<p>The simplest step in our algorithm is computing the acceleration 
caused by external forces. In the demonstration application found in the
 accompanying materials, you can apply an impulse to the fluid by 
clicking and dragging with the mouse. To implement this, we draw a spot 
into the velocity texture at the position of the click. The color of the
 spot encodes the direction and magnitude of the impulse: the red 
channel contains the magnitude in <em>x</em>, and the green channel contains the magnitude in <em>y</em>. The spot is actually a two-dimensional Gaussian "splat."</p>

<p>We use a fragment program to check each fragment's distance from the impulse position. Then we add the quantity <strong>c</strong> to the color:</p>

<p>
   <img src="gpugems_ch38_files/656equ01.jpg" alt="656equ01.jpg">
</p>

<p>Here, <strong>F</strong> is the force computed from the direction and length of the mouse drag, <em><font face="symbol">r</font></em> is the desired impulse radius, and (<em>x</em>, <em>y</em>) and (<em>x<sub>p</sub>
   </em>, <em>y<sub>p</sub>
   </em>) are the fragment position and impulse (click) position in window coordinates, respectively.</p>



<h4> Projection</h4>

<p>In the beginning of this section, we learned that the projection step
 is divided into two operations: solving the Poisson-pressure equation 
for <em>p,</em> and subtracting the gradient of <em>p</em> from the 
intermediate velocity field. This requires three fragment programs: the 
aforementioned Jacobi iteration program, a program to compute the 
divergence of the intermediate velocity field, and a program to subtract
 the gradient of <em>p</em> from the intermediate velocity field.</p>

<p>The divergence program shown in Listing 38-3 takes the intermediate velocity field as parameter <tt>w</tt> and one-half of the reciprocal of the grid scale as parameter <tt>halfrdx</tt>, and it computes the divergence according to the finite difference formula given in Table 38-1, on page 643.</p>

<p>The divergence is written to a temporary texture, which is then used as input to the <tt>b</tt> parameter of the Jacobi iteration program. The <tt>x</tt>
 parameter of the Jacobi program is set to the pressure texture, which 
is first cleared to all zero values (in other words, we are using zero 
as our initial guess for the pressure field). The <tt>alpha</tt> and <tt>rBeta</tt> parameters are set to -(<em><font face="symbol">d</font>x</em>)<sup>2</sup> and ¼, respectively.</p>

<p>To achieve good convergence on the solution, we typically use 40 to 
80 Jacobi iterations. Changing the number of Jacobi iterations will 
affect the accuracy of the simulation. It is not a good idea to go below
 20 iterations, because the error is noticeable. Using more iterations 
results in more detailed vortices and more overall accuracy, but it 
requires more computation time. After the Jacobi iterations are 
finished, we bind the pressure field texture to the parameter <tt>p</tt> in the following program, which computes the gradient of <em>p</em> according to the definition in Table 38-1 and subtracts it from the intermediate velocity field texture in parameter <tt>w</tt>. See Listing 38-4.</p>



<h4>Example 38-3. The Divergence Fragment Program</h4>


<pre><strong><em>void</em></strong> divergence(<strong><em>half2</em></strong> coords  : <strong><em>WPOS</em></strong>,   <strong><em>// grid coordinates</em></strong>
                
   <strong><em>out</em></strong> 
   <strong><em>half4</em></strong> div : <strong><em>COLOR</em></strong>,  <strong><em>// divergence</em></strong>
                
   <strong><em>uniform half</em></strong> halfrdx,   <strong><em>// 0.5 / gridscale</em></strong>
                
   <strong><em>uniform samplerRECT</em></strong> w)  <strong><em>// vector field</em></strong>
{
  <strong><em>half4</em></strong> wL = <strong><em>h4texRECT</em></strong>(w, coords - <strong><em>half2</em></strong>(1, 0));
  <strong><em>half4</em></strong> wR = <strong><em>h4texRECT</em></strong>(w, coords + <strong><em>half2</em></strong>(1, 0));
  <strong><em>half4</em></strong> wB = <strong><em>h4texRECT</em></strong>(w, coords - <strong><em>half2</em></strong>(0, 1));
  <strong><em>half4</em></strong> wT = <strong><em>h4texRECT</em></strong>(w, coords + <strong><em>half2</em></strong>(0, 1));

  div = halfrdx * ((wR.x - wL.x) + (wT.y - wB.y));
}</pre>




<h4>Example 38-4. The Gradient Subtraction Fragment Program</h4>


<pre><strong><em>void</em></strong> gradient(<strong><em>half2</em></strong> coords   : <strong><em>WPOS</em></strong>,   <strong><em>// grid coordinates</em></strong>
              
   <strong><em>out half4</em></strong> uNew : <strong><em>COLOR</em></strong>,  <strong><em>// new velocity</em></strong>
              
   <strong><em>uniform half</em></strong> halfrdx,    <strong><em>// 0.5 / gridscale</em></strong>
              
   <strong><em>uniform samplerRECT</em></strong> p,   <strong><em>// pressure</em></strong>
              
   <strong><em>uniform samplerRECT</em></strong> w)   <strong><em>// velocity</em></strong>
{
  <strong><em>half</em></strong> pL = <strong><em>h1texRECT</em></strong>(p, coords - <strong><em>half2</em></strong>(1, 0));
  <strong><em>half</em></strong> pR = <strong><em>h1texRECT</em></strong>(p, coords + <strong><em>half2</em></strong>(1, 0));
  <strong><em>half</em></strong> pB = <strong><em>h1texRECT</em></strong>(p, coords - <strong><em>half2</em></strong>(0, 1));
  <strong><em>half</em></strong> pT = <strong><em>h1texRECT</em></strong>(p, coords + <strong><em>half2</em></strong>(0, 1));

  uNew = <strong><em>h4texRECT</em></strong>(w, coords);
  uNew.xy -= halfrdx * <strong><em>half2</em></strong>(pR - pL, pT - pB);
}</pre>




<h4> Boundary Conditions</h4>

<p>In Section 38.2.4, we determined that our "fluid in a box" requires 
no-slip (zero) velocity boundary conditions and pure Neumann pressure 
boundary conditions. In Section 38.3.2 we learned that we can implement 
boundary conditions by reserving the one-pixel perimeter of our grid for
 storing boundary values. We update these values by drawing line 
primitives over the border, using a fragment program that sets the 
values appropriately.</p>

<p>First we should look at how our grid discretization affects the 
computation of boundary conditions. The no-slip condition dictates that 
velocity equals zero on the boundaries, and the pure Neumann pressure 
condition requires the normal pressure derivative to be zero at the 
boundaries. The boundary is defined to lie on the edge between the 
boundary cell and its nearest interior cell, but grid values are defined
 at cell centers. Therefore, we must compute boundary values such that 
the average of the two cells adjacent to any edge satisfies the boundary
 condition.</p>

<p>For the velocity boundary on the left side, for example, we have:</p>



<p>
   <strong>
      <a name="ch38equ15">Equation 17 </a></strong>
</p>


<p>

<a name="ch38equ15">   </a><a>
      <img src="gpugems_ch38_files/658equ01.jpg" alt="658equ01.jpg" border="0" hspace="5">
   </a>
</p>



<br>

<p>where <em>N</em> is the grid resolution. In order to satisfy this equation, we must set <strong>u</strong>
   <sub>0,</sub> 
   <em>
      <sub>j</sub>
   </em> equal to –<strong>u</strong>
   <sub>1,</sub>
   <em>
      <sub>j</sub>
   </em>. The pressure equation works out similarly. Using the forward difference approximation of the derivative, we get:</p>



<p>
   <strong>
      <a name="ch38equ16">Equation 18 </a></strong>
</p>


<p>

<a name="ch38equ16">   </a><a>
      <img src="gpugems_ch38_files/658equ02.jpg" alt="658equ02.jpg" border="0" hspace="5">
   </a>
</p>



<br>

<p>On solving this equation for <em>p</em>
   <sub>0,</sub>
   <em>
      <sub>j</sub>
   </em>, we see that we need to set each pressure boundary value to the value just inside the boundary.</p>

<p>We can use a simple fragment program for both the pressure and the velocity boundaries, as shown in Listing 38-5.</p>



<h4>Example 38-5. The Boundary Condition Fragment Program</h4>


<pre><strong><em>void</em></strong> boundary(<strong><em>half2</em></strong> coords : <strong><em>WPOS</em></strong>,    <strong><em>// grid coordinates</em></strong>
              
   <strong><em>half2</em></strong> offset : <strong><em>TEX1</em></strong>,    <strong><em>// boundary offset</em></strong>
              
   <strong><em>out half4</em></strong> bv : <strong><em>COLOR</em></strong>,   <strong><em>// output value</em></strong>
              
   <strong><em>uniform half</em></strong> scale,     <strong><em>// scale parameter</em></strong>
              
   <strong><em>uniform samplerRECT</em></strong> x)  <strong><em>// state field</em></strong>
{
  bv = scale * <strong><em>h4texRECT</em></strong>(x, coords + offset);
}</pre>


<p>
   Figure 38-6 demonstrates how this program works. The <tt>x</tt> parameter represents the texture (velocity or pressure field) from which we read interior values. The <tt>offset</tt> parameter contains the correct offset to the interior cells adjacent to the current boundary. The <tt>coords</tt> parameter contains the position in texture coordinates of the fragment being processed, so adding <tt>offset</tt> to it addresses a neighboring texel. At each boundary, we set <tt>offset</tt>
 to adjust our texture coordinates to the texel just inside the 
boundary. For the left boundary, we set it to (1, 0), so that it 
addresses the texel just to the right; for the bottom boundary, we use 
(0, 1); and so on. The <tt>scale</tt> parameter can be used to scale the value we copy to the boundary. For velocity boundaries, <tt>scale</tt> is set to -1, and for pressure it is set to 1, so that we correctly implement Equations 17 and 18, respectively.</p>

<div class="figure">
   <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/fig38-06.jpg">
      <img src="gpugems_ch38_files/fig38-06.jpg" alt="fig38-06.jpg">
   </a>
   <p>
      <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/fig38-06.jpg">Figure 38-6</a> Boundary Conditions on an MxN Grid</p>
</div>



<h2>38.4 Applications</h2>

<p>In this section we explore a variety of applications of the GPU simulation techniques discussed in this chapter.</p>



<h4>38.4.1 Simulating Liquids and Gases</h4>

<p>The most direct use of the simulation techniques is to simulate a 
continuous volume of a liquid or gas. As it stands, the simulation 
represents only the velocity of the fluid, which is not very 
interesting. It is more interesting if we put something else in the 
fluid. The demonstration application does this by maintaining an 
additional scalar field. This field represents the concentration of dye 
carried by the fluid. (Because it is an RGB texture, it is really three 
scalar fields: one for each of three dye colors.) Quantities like this 
are known as <em>passive scalars</em> because they are only carried along by the fluid; they do not affect how it flows.</p>

<p>If <em>d</em> is the concentration of dye, then the evolution of the dye field is governed by the following equation:</p>



<p>
   <strong>
      <a name="ch38equ17">Equation 19 </a></strong>
</p>


<p>

<a name="ch38equ17">   </a><a>
      <img src="gpugems_ch38_files/660equ01.jpg" alt="660equ01.jpg" border="0" hspace="5">
   </a>
</p>



<br>

<p>To simulate how the dye is carried by the fluid, we apply the 
advection operator to the scalar field, just as we do for the velocity. 
If we also want to account for the diffusion of the dye in the fluid, we
 add a diffusion term:</p>



<p>
   <strong>
      <a name="ch38equ18">Equation 20 </a></strong>
</p>


<p>

<a name="ch38equ18">   </a><a>
      <img src="gpugems_ch38_files/660equ02.jpg" alt="660equ02.jpg" border="0" hspace="5">
   </a>
</p>




<br>

<p>where <em><font face="symbol">g</font></em> is the coefficient of the
 diffusion of dye in water (or whatever liquid we assume the fluid is). 
To implement dye diffusion, we use Jacobi iteration, just as we did for 
viscous diffusion of velocity. Note that the demonstration application 
does not actually perform diffusion of the dye, because numerical error 
in the advection term causes it to diffuse anyway. We added another term
 to Equation 20, <em>S</em>. This term represents any sources of dye. The application implements this term by adding dye anywhere we click.</p>



<h4>38.4.2 Buoyancy and Convection</h4>

<p>Temperature is an important factor in the flow of many fluids. 
Convection currents are caused by the changes in density associated with
 temperature changes. These currents affect our weather, our oceans and 
lakes, and even our coffee. To simulate these effects, we need to add 
buoyancy to our simulation.</p>

<p>The simplest way to incorporate buoyancy is to add a new scalar field for temperature, <em>T</em>,
 to the simulation. We can then insert an additional buoyancy operator 
that adds force where the local temperature is higher than a given 
ambient temperature, <em>T</em>
   <sub>0</sub>:</p>




<p>
   <strong>
      <a name="ch38equ19">Equation 21 </a></strong>
</p>


<p>

<a name="ch38equ19">   </a><a>
      <img src="gpugems_ch38_files/661equ01.jpg" alt="661equ01.jpg" border="0" hspace="5">
   </a>
</p>



<br>

<p>In this equation, <strong><img src="gpugems_ch38_files/U0135.GIF" class="articleIcon" alt="U0135.GIF"></strong> is the vertical direction and <em><font face="symbol">s</font></em>
 is a constant scale factor. This force can be implemented in a simple 
fragment program that evaluates Equation 21 at each fragment, scales the
 result by the time step, and adds it to the current velocity.</p>


<h4> Smoke and Clouds</h4>

<p>We now have almost everything we need to simulate smoke. What we have
 presented so far is similar to the smoke simulation technique 
introduced by Fedkiw et al. 2001. In addition to calculating the 
velocity and pressure fields, a smoke simulation must maintain scalar 
fields for smoke density, <em>d</em>, and temperature, <em>T</em>. The 
smoke density is advected by the velocity field, just like the dye we 
described earlier. The buoyant force is modified to account for the 
gravitational pull on dense smoke:</p>



<p>
   <strong>
      <a name="ch38equ20">Equation 22 </a></strong>
</p>


<p>

<a name="ch38equ20">   </a><a>
      <img src="gpugems_ch38_files/661equ02.jpg" alt="661equ02.jpg" border="0" hspace="5">
   </a>
</p>



<br>

<p>where <em>k</em> is a constant mass scale factor.</p>

<p>By adding a source of smoke density and temperature (possibly 
representing a smokestack or the tip of a cigarette) at a given location
 on the grid, we simulate smoke. The paper by Fedkiw et al. describes 
two other differences from our basic simulation. They use a staggered 
grid to improve accuracy, and they add a vorticity confinement force to 
increase the amount of swirling motion in the smoke. Both extensions are
 discussed in the next section.</p>

<p>As demonstrated in Harris et al. 2003, a more complex simulation can 
be used
  to simulate clouds on the GPU. A sequence of stills from a 2D GPU 
cloud simulation
is shown in Figure 38-7. The cloud simulator combines fluid simulation 
with a thermodynamic simulation (including buoyancy), as well as a 
simulation of water condensation and evaporation. A 128x128 cloud 
simulation runs at over 80 iterations per second on an NVIDIA GeForce FX
 5950 Ultra GPU.</p>

<div class="figure">
   <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/fig38-07.jpg">
      <img src="gpugems_ch38_files/fig38-07.jpg" alt="fig38-07.jpg">
   </a>
   <p>
      <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/fig38-07.jpg">Figure 38-7</a> Cloud Simulation</p>
</div>



<h2>38.5 Extensions</h2>

<p>The fluid simulation presented in this chapter is a building block 
that can serve as the basis for more complex simulations. There are many
 ways to extend this basic simulation. To get you started, we describe 
some useful extensions.</p>



<h4>38.5.1 Vorticity Confinement</h4>

<p>The motion of smoke, air and other low-viscosity fluids typically 
contains rotational flows at a variety of scales. This rotational flow 
is <em>vorticity</em>. As Fedkiw et al. explained, numerical dissipation
 caused by simulation on a coarse grid damps out these interesting 
features (Fedkiw et al. 2001). Therefore, they used <em>vorticity confinement</em> to restore these fine-scale motions. Vorticity confinement works by first computing the vorticity, <strong><font face="symbol">w</font></strong> = <img src="gpugems_ch38_files/U2207.GIF" class="articleIcon" alt="U2207.GIF"> x <strong>u</strong>. From the vorticity we compute a normalized vorticity vector field:</p>

<p>
   <img src="gpugems_ch38_files/662equ01.jpg" alt="662equ01.jpg">
</p>

<p>Here, <a href="http://http.developer.nvidia.com/GPUGems/elementLinks/662equ02.jpg">
      <img src="gpugems_ch38_files/662equ02.jpg" alt="662equ02.jpg" border="0" hspace="5">
   </a> The vectors in this vector field point from areas of lower 
vorticity to areas of higher vorticity. From these vectors we compute a 
force that can be used to restore an approximation of the dissipated 
vorticity:</p>

<p>
   <img src="gpugems_ch38_files/663equ01.jpg" alt="663equ01.jpg">
</p>

<p>Here <em><img src="gpugems_ch38_files/U220A.htm" class="articleIcon" alt="U220A.GIF"></em> is a user-controlled scale parameter. The "curl" operator, <img src="gpugems_ch38_files/U2207.GIF" class="articleIcon" alt="U2207.GIF">
 x, can be derived using the definitions of the gradient and the 
cross-product operator. The accompanying source code implements 
vorticity confinement.</p>



<h4>38.5.2 Three Dimensions</h4>

<p>All the simulations presented in this chapter are two-dimensional. 
There is nothing preventing us from extending them to 3D. The equations 
remain essentially the same, but we must extend them to incorporate a 3D
 velocity, <strong>u</strong> = (<em>u</em>, <em>v</em>, <em>w</em>). 
The fragment programs must be rewritten to account for this; samples 
from four neighbors in two dimensions become samples from six neighbors 
in three dimensions.</p>

<p>The biggest change is in how the vector and scalar fields are 
represented. One option is to use 3D textures. This is a problem on 
hardware that does not support 3D floating-point textures. In this 
situation, we can tile the slabs of a 3D texture in a grid stored in a 
2D texture (for example, a 32x32x32 grid would tile onto a 256x128 2D 
texture, with eight tiles in one dimension and four in the other). This 
technique, called <em>flat 3D textures,</em> is presented in detail in Harris et al. 2003.</p>



<h4>38.5.3 Staggered Grid</h4>

<p>In our simulation we represent velocity, pressure, and any other 
quantities at cell centers. This is just one way to discretize the 
continuous domain on which we represent our fluid. This approach is 
known as a <em>collocated</em>, or <em>cell-centered,</em> discretization. Another way is to use a <em>staggered grid</em>.
 In a staggered grid, we represent scalar quantities (such as pressure) 
at cell centers and vector quantities (such as velocity) at the 
boundaries between cells. Specifically, on a two-dimensional grid, we 
represent the horizontal velocity, <em>u</em>, at the right edge of each cell and the vertical velocity, <em>v</em>,
 at the top edge of each cell. The staggered grid discretization 
increases the accuracy of many calculations. It can also reduce 
numerical oscillations that may arise when forces such as buoyancy are 
applied on a cell-centered grid. Details of the implementation of fluid 
simulation on a staggered grid can be found in Griebel et al. 1998.</p>




<h4>38.5.4 Arbitrary Boundaries</h4>

<p>So far we have assumed that our fluid exists in a rectangular box 
with flat, solid sides. If boundaries of arbitrary shape and location 
are important, you need to extend the simulation.</p>

<p>Incorporating arbitrary boundaries requires applying the boundary 
conditions (discussed in Section 38.3.3) at arbitrary locations. This 
means that at each cell, we must determine in which direction the 
boundaries lie in order to compute the correct boundary values. This 
simulation requires more decisions to be made at each cell, leading to a
 slower and more complicated simulation. However, many interesting 
effects can be created this way, such as smoke flowing around obstacles.
 Moving boundaries can even be incorporated, as in Fedkiw et al. 2001. 
We refer you to that paper as well as Griebel et al. 1998 for 
implementation details.</p>



<h4>38.5.5 Free Surface Flow</h4>

<p>Another assumption we made is that our fluid is continuous—the only 
boundaries we represent are the solid boundaries of the box. So we 
cannot simulate things like the ocean surface, where there is an 
interface between the water and air. This type of interface is called a <em>free surface</em>.
 Extending our simulation to incorporate a free surface requires 
tracking the location of the surface as it moves through cells. Methods 
for implementing free surface flow can be found in Griebel et al. 1998.</p>


<h2>38.6 Conclusion</h2>

<p>The power and programmability now available in GPUs enables fast 
simulation of a wide variety of phenomena. Underlying many of these 
phenomena is the dynamics of fluid motion.</p>

<p>After reading this chapter, you should have a fundamental 
understanding of the mathematics and technology you need to implement 
basic fluid simulations on the GPU. From these initial ideas you can 
experiment with your own simulation concepts and incorporate fluid 
simulation into graphics applications. We hope these techniques become 
powerful new tools in your repertoire.</p>



<h2>38.7 References</h2>



<p>
   <a name="ch38bib01_01">Bolz, J., I. Farmer, E. Grinspun, and P. 
Schröder. 2003. "Sparse Matrix Solvers on the GPU: Conjugate Gradients 
and Multigrid." In <em>Proceedings of SIGGRAPH 2003</em>.</a></p>

<p>
<a name="ch38bib01_01">   </a><a name="ch38bib01_02">Chorin, A.J., and J.E. Marsden. 1993. <em>A Mathematical Introduction to Fluid Mechanics</em>. 3rd ed. Springer.</a></p>

<p>
<a name="ch38bib01_02">   </a><a name="ch38bib01_03">Fedkiw, R., J. Stam, and H.W. Jensen. 2001. "Visual Simulation of Smoke." In <em>Proceedings of SIGGRAPH 2001</em>.</a></p>

<p>
<a name="ch38bib01_03">   </a><a name="ch38bib01_04">Golub, G.H., and C.F. Van Loan. 1996. <em>Matrix Computations</em>. 3rd ed. The Johns Hopkins University Press.</a></p>

<p>
<a name="ch38bib01_04">   </a><a name="ch38bib01_05">Goodnight, N., C. 
Woolley, G. Lewin, D. Luebke, and G. Humphreys. 2003. "A Multigrid 
Solver for Boundary Value Problems Using Programmable Graphics 
Hardware." In <em>Proceedings of the SIGGRAPH/Eurographics Workshop on Graphics Hardware 2003</em>.</a></p>

<p>
<a name="ch38bib01_05">   </a><a name="ch38bib01_06">Griebel, M., T. Dornseifer, and T. Neunhoeffer. 1998. <em>Numerical Simulation in Fluid Dynamics: A Practical Introduction</em>. Society for Industrial and Applied Mathematics.</a></p>

<p>
<a name="ch38bib01_06">   </a><a name="ch38bib01_07">Harris, M.J., W.V. Baxter, T. Scheuermann, and A. Lastra. 2003. "Simulation of Cloud Dynamics on Graphics Hardware." In <em>Proceedings of the SIGGRAPH/Eurographics Workshop on Graphics Hardware 2003</em>.</a></p>

<p>
<a name="ch38bib01_07">   </a><a name="ch38bib01_08">Krüger, J., and R. Westermann. 2003. "Linear Algebra Operators for GPU Implementation of Numerical Algorithms." In <em>Proceedings of SIGGRAPH 2003</em>.</a></p>

<p>
<a name="ch38bib01_08">   </a><a name="ch38bib01_09">Stam, J. 1999. "Stable Fluids." In <em>Proceedings of SIGGRAPH 1999</em>.</a></p>



<a name="ch38bib01_09">		<!-- generated html end -->

		<!-- Copyright info for The Cg Tutorial -->

</a><hr>

<h4><a name="ch38bib01_09">Copyright</a></h4>



<p><a name="ch38bib01_09">Many of the designations used by manufacturers
 and sellers to distinguish their products are claimed as trademarks. 
Where those designations appear in this book, and Addison-Wesley was 
aware of a trademark claim, the designations have been printed with 
initial capital letters or in all capitals.</a></p>



<p><a name="ch38bib01_09">The authors and publisher have taken care in 
the preparation of this book, but make no expressed or implied warranty 
of any kind and assume no responsibility for errors or omissions. No 
liability is assumed for incidental or consequential damages in 
connection with or arising out of the use of the information or programs
 contained herein.</a></p>



<p><a name="ch38bib01_09">The publisher offers discounts on this book 
when ordered in quantity for bulk purchases and special sales. For more 
information, please contact:</a></p>





<p><a name="ch38bib01_09">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;U.S.&nbsp;Corporate&nbsp;and&nbsp;Government&nbsp;Sales<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="skype_pnh_print_container_1319822120">(800)&nbsp;382-3419</span><span tabindex="-1" dir="ltr" class="skype_pnh_container"><span class="skype_pnh_mark"> begin_of_the_skype_highlighting</span>&nbsp;<span dir="ltr" title="Call this phone number in United States of America with Skype: +18003823419" class="skype_pnh_highlighting_inactive_common"><span title="Skype actions" skypeaction="skype_dropdown" class="skype_pnh_left_span">&nbsp;&nbsp;</span><span skypeaction="skype_dropdown" title="Skype actions" class="skype_pnh_dropart_span"><span skypeaction="skype_dropdown" style="background-position: -5849px 1px ! important;" class="skype_pnh_dropart_flag_span">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;</span><span class="skype_pnh_textarea_span"><span class="skype_pnh_text_span">(800)&nbsp;382-3419</span></span><span class="skype_pnh_right_span">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>&nbsp;<span class="skype_pnh_mark">end_of_the_skype_highlighting</span></span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a><a href="mailto:corpsales@pearsontechgroup.com">corpsales@pearsontechgroup.com</a>

</p>



<p>For sales outside of the U.S., please contact:</p>



<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;International&nbsp;Sales<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="mailto:international@pearsoned.com">international@pearsoned.com</a>

</p>



<p>Visit Addison-Wesley on the Web: <a href="http://www.awprofessional.com/">www.awprofessional.com</a>

</p>





<p>Library of Congress Control Number: 2004100582</p>



<p>GeForce™&nbsp;and&nbsp;NVIDIA&nbsp;Quadro<sup>®</sup>&nbsp;are&nbsp;trademarks&nbsp;or&nbsp;registered&nbsp;trademarks&nbsp;of&nbsp;NVIDIA&nbsp;Corporation.<br>RenderMan<sup>®</sup>&nbsp;is&nbsp;a&nbsp;registered&nbsp;trademark&nbsp;of&nbsp;Pixar&nbsp;Animation&nbsp;Studios.<br>"Shadow&nbsp;Map&nbsp;Antialiasing"&nbsp;©&nbsp;2003&nbsp;NVIDIA&nbsp;Corporation&nbsp;and&nbsp;Pixar&nbsp;Animation&nbsp;Studios.<br>"Cinematic&nbsp;Lighting"&nbsp;©&nbsp;2003&nbsp;Pixar&nbsp;Animation&nbsp;Studios.<br>Dawn&nbsp;images&nbsp;©&nbsp;2002&nbsp;NVIDIA&nbsp;Corporation.&nbsp;Vulcan&nbsp;images&nbsp;©&nbsp;2003&nbsp;NVIDIA&nbsp;Corporation.</p>





<p>Copyright © 2004 by NVIDIA Corporation.</p>



<p>All rights reserved. No part of this publication may be reproduced, 
stored in a retrieval system, or transmitted, in any form, or by any 
means, electronic, mechanical, photocopying, recording, or otherwise, 
without the prior consent of the publisher. Printed in the United States
 of America. Published simultaneously in Canada.</p>





<p>For information on obtaining permission for use of material from this work, please submit a written request to:</p>



<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pearson&nbsp;Education,&nbsp;Inc.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rights&nbsp;and&nbsp;Contracts&nbsp;Department<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;One&nbsp;Lake&nbsp;Street<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Upper&nbsp;Saddle&nbsp;River,&nbsp;NJ&nbsp;07458</p>



<p>Text printed on recycled and acid-free paper.</p>





<p>5 6 7 8 9 10 QWT 09 08 07</p>



<p>5th Printing September 2007</p>





<!-- <div align="right" style=" color:#999999;">Last Update: 15:05 05/12/2008</div> -->

  </div>

  

  <div id="left" class="column">		

    <a href="http://developer.nvidia.com/">Developer Site Homepage</a><br><br>

		<a href="http://news.developer.nvidia.com/">Developer News Homepage</a><br><br>



		<img src="gpugems_ch38_files/divider.gif" alt="" align="" border="0"><br><br>



		<a href="https://nvdeveloper.nvidia.com/">Developer Login</a><br><br>

		<a href="http://developer.nvidia.com/page/registered_developer_program.html">Become a<br>Registered Developer</a><br><br>



		<img src="gpugems_ch38_files/divider.gif" alt="" align="" border="0"><br><br>



		<a href="http://developer.nvidia.com/page/tools.html">Developer Tools</a><br><br>

		<a href="http://developer.nvidia.com/page/documentation.html">Documentation</a><br><br>

		<a href="http://developer.nvidia.com/page/directx.html">DirectX</a><br><br>

		<a href="http://developer.nvidia.com/page/opengl.html">OpenGL</a><br><br>

		<a href="http://developer.nvidia.com/object/cuda.html">GPU Computing</a><br><br>

		<a href="http://developer.nvidia.com/page/handheld.html">Handheld</a><br><br>

		<a href="http://developer.nvidia.com/page/event_calendar.html">Events Calendar</a><br><br>



		<img src="gpugems_ch38_files/divider.gif" alt="" align="" border="0"><br><br>



		<a href="http://developer.nvidia.com/object/newsletter_signup.html">Newsletter Sign-Up</a><br><br>

		<a href="http://developer.nvidia.com/object/downloading_drivers.html">Drivers</a><br><br>

		<a href="http://developer.nvidia.com/page/jobs.html">Jobs (1)</a><br><br>

		<a href="http://developer.nvidia.com/object/contact_us.html">Contact</a><br><br>

		<a href="http://developer.nvidia.com/object/legal_info.html">Legal Information</a><br><br>



		<img src="gpugems_ch38_files/divider.gif" alt="" align="" border="0"><br><br>

		<a href="http://surveys.nvidia.com/index.jsp?pi=c1655cd3f4d0fb4bfdee853f141f9a75">Site Feedback</a>		

	</div>

	

  <div id="right" class="column"><ul><li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_copyrightpg.html">Copyright</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_pref01.html">Foreword</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_pref02.html">Preface</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_pref03.html">Contributors</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_part01.html"><i>Part I: Natural Effects</i></a></li>
<ul>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch01.html">Chapter 1. Effective Water Simulation from Physical Models</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch02.html">Chapter 2. Rendering Water Caustics</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch03.html">Chapter 3. Skin in the "Dawn" Demo</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch04.html">Chapter 4. Animation in the "Dawn" Demo</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch05.html">Chapter 5. Implementing Improved Perlin Noise</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch06.html">Chapter 6. Fire in the "Vulcan" Demo</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch07.html">Chapter 7. Rendering Countless Blades of Waving Grass</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch08.html">Chapter 8. Simulating Diffraction</a></li>
</ul><li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_part02.html"><i>Part II: Lighting and Shadows</i></a></li>
<ul>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch09.html">Chapter 9. Efficient Shadow Volume Rendering</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html">Chapter 10. Cinematic Lighting</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch11.html">Chapter 11. Shadow Map Antialiasing</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch12.html">Chapter 12. Omnidirectional Shadow Mapping</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch13.html">Chapter 13. Generating Soft Shadows Using Occlusion Interval Maps</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch14.html">Chapter 14. Perspective Shadow Maps: Care and Feeding</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch15.html">Chapter 15. Managing Visibility for Per-Pixel Lighting</a></li>
</ul><li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_part03.html"><i>Part III: Materials</i></a></li>
<ul>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch16.html">Chapter 16. Real-Time Approximations to Subsurface Scattering</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch17.html">Chapter 17. Ambient Occlusio</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch18.html">Chapter 18. Spatial BRDFs</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch19.html">Chapter 19. Image-Based Lighting</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch20.html">Chapter 20. Texture Bombing</a></li>
</ul><li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_part04.html"><i>Part IV: Image Processing</i></a></li>
<ul>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch21.html">Chapter 21. Real-Time Glow</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch22.html">Chapter 22. Color Controls</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch23.html">Chapter 23. Depth of Field: A Survey of Techniques</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch24.html">Chapter 24. High-Quality Filtering</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch25.html">Chapter 25. Fast Filter-Width Estimates with Texture Maps</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch26.html">Chapter 26. The OpenEXR Image File Format</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch27.html">Chapter 27. A Framework for Image Processing</a></li>
</ul><li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_part05.html"><i>Part V: Performance and Practicalities</i></a></li>
<ul>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch28.html">Chapter 28. Graphics Pipeline Performance</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch29.html">Chapter 29. Efficient Occlusion Culling</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch30.html">Chapter 30. The Design of FX Composer</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch31.html">Chapter 31. Using FX Composer</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch32.html">Chapter 32. An Introduction to Shader Interfaces</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch33.html">Chapter 33. Converting Production RenderMan Shaders to Real-Time</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch34.html">Chapter 34. Integrating Hardware Shading into Cinema 4D</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch35.html">Chapter 35. Leveraging High-Quality Software Rendering Effects in Real-Time Applications</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch36.html">Chapter 36. Integrating Shaders into Applications</a></li>
</ul><li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_part06.html"><i>Part VI: Beyond Triangles</i></a></li>
<ul>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch37.html">Chapter 37. A Toolkit for Computation on GPUs</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch38.html"><font color="#45b900;"><b><i>Chapter 38. Fast Fluid Dynamics Simulation on the GPU</i></b></font></a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch39.html">Chapter 39. Volume Rendering Techniques</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch40.html">Chapter 40. Applying Real-Time Shading to 3D Ultrasound Visualization</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch41.html">Chapter 41. Real-Time Stereograms</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch42.html">Chapter 42. Deformers</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_app01.html">Appendix</a></li>
</ul>
</ul></div>

</div>



<div id="footer"></div>





<!--WEBSIDESTORY CODE HBX1.0 (Universal)-->

<!--COPYRIGHT 1997-2005 WEBSIDESTORY,INC. ALL RIGHTS RESERVED. U.S.PATENT No. 6,393,479B1. MORE INFO:http://websidestory.com/privacy-->

<script language="javascript">

var _hbEC=0,_hbE=new Array;function _hbEvent(a,b){b=_hbE[_hbEC++]=new Object();b._N=a;b._C=0;return b;}

var hbx=_hbEvent("pv");hbx.vpc="HBX0100u";hbx.gn="a.nvidia.com";

hbx.acct="DM55061879AA96EN3";//developer

hbx.pn="PUT+PAGE+NAME+HERE";

hbx.mlc="CONTENT+CATEGORY";

hbx.pndef="home.html";

hbx.ctdef="full";

hbx.lt="auto";

hbx.dlf=".run,.8bi,.asx,.bat,.cg,.chm,.cpp,.db,.dds,.dll,.dsp,.dsw,.fp,.fx,.fxcomposer,.fxproj,.h,.hdr,.hpp,.ico,.img,.inf,.ini,.key,.lib,.lst,.msi,.ncb,.opt,.P3D,.plg,.exr,.rc,.res,.sh,.sln,.spc,.str,.tga,.txt,.vcproj,.xml";

</script><script language="javascript1.1" defer="defer" src="gpugems_ch38_files/hbx.js"></script>

<!--END WEBSIDESTORY CODE-->



</body></html>